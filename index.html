<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="stylesheet" href="css/aniloop.css" />
		<title>Document</title>
	</head>
	<body>
		<section class="container">
			<div class="spot-container">
				<div class="spot" data-behavior="spot" id="spot-1">
					<div class="pop-trig" data-behavior="spot-control">a</div>
					<div class="pop-cont" data-behavior="spot-content">
						<div class="pop">Content 1</div>
					</div>
				</div>

				<div class="spot" data-behavior="spot" id="spot-2">
					<div class="pop-trig" data-behavior="spot-control">B</div>
					<div class="pop-cont" data-behavior="spot-content">
						<div class="pop">Content 2</div>
					</div>
				</div>

				<div class="spot" data-behavior="spot" id="spot-3">
					<div class="pop-trig" data-behavior="spot-control">C</div>
					<div class="pop-cont" data-behavior="spot-content">
						<div class="pop">Content 3</div>
					</div>
				</div>
			</div>
		</section>
		<section>
			<div data-behavior="spot-control" data-content='[data-behavior="spot-content"]'>
				FAFAFAFAFA
			</div>
		</section>
		<br />
		<a href="#">here I am</a>

		<script>
			const spottery = {
				init: function (selector = '[data-behavior="spot"]', opts) {
					const defaults = {
						spotSelector: selector,
						spotControlSelector: '[data-behavior="spot-control"]',
						spotContentSelector: '[data-behavior="spot-content"]',
						animateClassName: "is-animated",
						activeClassName: "is-active",
					};
					const options = (this.options = { ...defaults, ...opts });

					this.options.spots = document.querySelectorAll(options.spotSelector);
					const spotContents = (this.options.spotContents = document.querySelectorAll(
						options.spotContentSelector
					));
					const spotControls = (this.options.spotControls = document.querySelectorAll(
						options.spotControlSelector
					));

					// Bind clickout events
					document.addEventListener("click", this.clickOut.bind(this));

					// Bind spot events
					spotControls.forEach((el) => {
						//console.log('control: ', el)
						//el.addEventListener("click", this.addAnimationClass.bind(this));
						el.addEventListener("click", this.showSpotContent.bind(this));
					});

					// Get content heights
					spotContents.forEach((contentEl) => {
						const el = contentEl.firstElementChild;
						const rect = el.getBoundingClientRect();
						const pos = {
							x: rect.x - el.clientWidth / 2,
						};
						pos.y = rect.y;

						const translateX =
							pos.x > 0
								? pos.x + el.clientWidth > window.innerWidth
									? pos.x - rect.x + (window.innerWidth - (pos.x + el.clientWidth))
									: pos.x - rect.x
								: - pos.x - el.clientWidth / 2;

						console.log(el.clientHeight, el.clientWidth, pos.x + el.clientWidth, window.innerWidth);
						console.log(translateX);

						contentEl.style.transform = 'translateX(' + translateX + 'px)'

					});
				},
				current: -1,
				// One time on page load.
				// To prevent animations on load another class is required.
				addAnimationClass: function (evt, targetControl) {
					const options = this.options;
					const target = evt ? evt.currentTarget : targetControl;
					console.log(evt);
					const spot = target.closest(options.spotSelector);
					const content = spot
						? spot.querySelector(options.spotContentSelector)
						: this.contentLookup(target);

					if (content) {
						content.classList.add(options.animateClassName);
						target.removeEventListener("click", this.addAnimationClass);
					}
				},

				showSpotContent: function (evt, targetEl) {
					const options = this.options;
					const el = evt ? evt.currentTarget : targetEl;

					// Find spot container element
					const spot = this.spotLookup(el);

					// Find content element
					const content = this.contentLookup(spot);

					let activeEls = document.querySelectorAll(
						options.spotSelector +
							"." +
							options.activeClassName +
							"," +
							options.spotControlSelector +
							"." +
							options.activeClassName
					);
					// Find out if elemenet already has spot content visible
					const notActive = spot.classList.contains(options.activeClassName)
						? false
						: true;
					let current;
					const spots = options.spots.entries();

					for (item of spots) {
						if (spot.isEqualNode(item[1])) {
							current = item[0];
						}
					}

					//Prepare animations
					this.addAnimationClass(evt, targetEl);

					// Switch all active spots to inactive state
					activeEls.forEach((el) => {
						el.classList.remove(options.activeClassName);
					});

					// Add active only if it is not active
					if (notActive) {
						spot.classList.add(options.activeClassName);
						el.classList.add(options.activeClassName);
						this.current = current;
					}
				},

				spotLookup: function (el) {
					const options = this.options;
					// Try to find parent spot element, otherwise return target element itself
					let spot = el.closest(options.spotSelector);
					const content = this.contentLookup(el);

					if (content) {
						spot = content.closest(options.spotSelector);
					}

					return spot;
				},

				contentLookup: function (el) {
					const options = this.options;
					let contentAttr = el.dataset.content;

					const content = contentAttr
						? document.querySelector(contentAttr)
						: el.querySelector(options.spotContentSelector);
					return content;
				},

				clickOut: function (evt) {
					const options = this.options;
					let triggerEls = options.spotControls;
					let activeEls = document.querySelectorAll("." + options.activeClassName);

					if (evt.target.dataset.behavior === "spot-control") {
						return;
					} else {
						activeEls.forEach((el) => {
							el.classList.remove(options.activeClassName);
						});
					}
				},

				next: function () {
					const options = this.options;
					const spots = options.spots;
					const current = this.current;

					this.current = spots.length - 1 > current ? current + 1 : 0;

					const control = spots[this.current].querySelector(options.spotControlSelector);

					this.showSpotContent(null, control);
				},

				prev: function () {
					const options = this.options;
					const spots = options.spots;
					const current = this.current;

					this.current = current < 1 ? spots.length - 1 : current - 1;

					const control = spots[this.current].querySelector(options.spotControlSelector);

					this.showSpotContent(null, control);
				},
			};

			const spots = Object.assign(spottery);
			spots.init();

			//spots.addAnimationClass(null, document.getElementById("spot-control-2"));
			//spots.showSpotContent(null, document.getElementById("spot-control-2"));

			// const triggers = document.querySelectorAll('.pop-trig')fvfv

			// document.addEventListener('click', clickOut)
			// triggers.forEach((el) => {
			// 	el.addEventListener('click', addAnimationClass)
			// 	el.addEventListener('click', showPopper)
			// })

			// // One time on page load.
			// // To prevent animations on load another class is required.
			// function addAnimationClass(e) {
			// 	const target = e.currentTarget
			// 	const spot = target.closest('.spot')

			// 	const el = spot.querySelector('.pop-cont')
			// 	el.classList.add('is-animated')
			// 	target.removeEventListener('mouseover', addAnimationClass)
			// }

			// function showPopper(e) {
			// 	let activeEls = document.querySelectorAll('.is-active')
			// 	const notActive = e.currentTarget.classList.contains('is-active') ? false : true

			// 	// Switch all active spots to inactive state
			// 	activeEls.forEach((el) => {
			// 		el.classList.remove('is-active')
			// 	})

			// 	// Skip if already active
			// 	if (notActive) {
			// 		e.target.classList.add('is-active')
			// 	}
			// }

			// function clickOut(e) {
			// 	let triggerEls = document.querySelectorAll('.pop-trig')
			// 	let activeEls = document.querySelectorAll('.is-active')

			// 	if(e.target.classList.contains('pop-trig')) {
			// 		return
			// 	} else {
			// 		activeEls.forEach((el) => {
			// 			el.classList.remove('is-active')
			// 		})
			// 	}
			// }
		</script>
	</body>
</html>
